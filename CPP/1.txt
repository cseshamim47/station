###### some useful codes ######
code -r name.cpp
ls ./ *Folder_Name* -Recurse -Directory
ls ./ *file_name* -Recurse -File

###### some useful shortcuts ######
ctrl shift o -> all function in a file
ctrl g (put line number ) -> go to that line
ctrl + click on function 
ctrl + p to find some tab

###### TO DOS ######

# Things I'll learn before I die if Allah wills

1. Centroid Decomposition


## Add into snippet
transform(all(tmp),tmp.begin(),::tolower);

###### DATES ######
9 sep : 5 hours
10 sep : 4.5 hours
11 sep : 4 hrs 20 mins [target: 7 hrs] 
12 sep : 5 hrs 20 mins [target: 7 hours]
13 sep : 7 hrs +  [target: 9 hours]
14 sep : 4 hrs
15 sep : 4 hrs

16 sep : 6 hrs [target : 8 hours]
17 sep : 5 hrs 40 mins [target : 8 hours]
18 sep : 2 hrs 30 mins 
19 sep : 0 hrs
20 sep : 7 hr 20 min [target : 10 hrs]
21 sep : 7 hrs
22 sep : 5 hrs

avg = 6+5+2+0+7+7+5 = 32/7 = 4.5 hrs 

23 sep : 4 hrs
24 sep : 2.75 hrs
25 sep : 8 hrs
26 sep : 0 hrs
27 sep : 5 hrs
28 sep : 2 hrs
29 sep : sick

avg = 

30 sep : 5 hrs





Some notes:
Finding Length of LIS
#1. Use DP -> takes O(n*n). Gets MLE if n > 5000
#2. Use array element as index then find the maximum frequency F = (1 to a[i]-1). LIS ending at that element will be F+1.
ex: array a[] =  5 3 4 8 1

index : 0 1 2 3 4 5 6 7 8 9 10
a[0]  : 0 0 0 0 0 1 0 0 0 0 0 [as 5 is the starting]
a[1]  : 0 0 0 1 0 1 0 0 0 0 0 [0-2 index have value 0]
a[2]  : 0 0 0 1 2 1 0 0 0 0 0 [0-3 index have max value 1]
a[3]  : 0 0 0 1 2 1 0 0 3 0 0 [0-7 index have max value 2]
a[4]  : 0 1 0 1 2 1 0 0 3 0 0 [0 index have max value 0]
hence 3 is the length of longest increasing subsequence

this technique will take O(max(a[])^2). It can to optimized to O(nlogn if we use segment tree). Maximum length of array should not be more than 1e7

#3. We can use only index to store LIS ending at a particular value. TC : O(n*n). N is the number length of the array.

ex : array a[] = 5 3 4 8 1

index     : 0 1 2 3 4 
ans[]     : 1 1 1 1 1 [minimum LIS. Only taking one element]

a[0] = 5  : 1 1 1 1 1 [Till 5, 1 is max LIS]
a[1] = 3  : 1 1 1 1 1 [Till 3, meaning [5 3] has only 1 len of LIS]
a[2] = 4  : 1 1 2 1 1 [Till 4, [3 4] is max LIS. So we traverse back from ith index to find the max value from ans. Our LIS will be max value +1 for a index]
a[3] = 8  : 1 1 2 3 1 [LIS : 3 4 8]
a[4] = 1  : 1 1 2 3 1 

Since we traverse back from i-1th index to 0th index to look for max LIS, it's gonna take O(n*n) time.

#4. Printing LIS using approach 3
Take another array to backtrack beside ans array
Whenever you find a change in ans array, note down which index is responsible for the change.

ex : 
array a[] : 5 3 4 8 1

index     : 0 1 2 3 4
ans[0]    : 1 1 1 1 1 
backtrk[0]: 0 1 2 3 4 [initially set all value to it's index]
ans[1]    : 1 1 1 1 1
backtrk[1]: 0 1 2 3 4
ans[2]    : 1 1 2 1 1
backtrk[2]: 0 1 1 3 4 [index 2 is changed to 1 as [3 4] is LIS till now]
ans[3]    : 1 1 2 3 1
backtrk[3]: 0 1 1 2 4
.
.
after doing the above operation, we can simply find the max LIS index and backtrack to print the actual values of LIS

#5. Improving approach 3 using binary search. TC : O(nlogn)

At first, let's understand the simpler way of doing it.

ex : a[] -> 2 6 3 4 1 7 9
We can generate all LIS ending at a particular index. Like all valid subset which are increasing subsequence. 
Like : 
2 [till 0th index]
2 6 [till 1th index]
6

on the 3rd index we have value 3. Now we need to check which sequences will remain valid if we put this value 3 at the back. 
2 6 3 will break the LIS but,
2 3 won't
so far we got,
[+3] itself
[2 +3] by removing 6 and putting 3

next value is 4, if we try putting it where it belongs,
[2 3 +4] 
[3 +4]
[2 +4]
and many more...

next value is 1. 1 can only sit in the first index, because all other value is greater than 1 
[1]

next val : 7
[2 3 4 +7]
[3 4 +7]
[2 6 +7]
and many more

next value is 9. 
[2 3 4 7 +9]
[3 4 7 +9]
[2 6 7 +9]

since 9 is the last element of original array, LIS will be length of 5. [2 3 4 7 9]. 

This technique is not so time & memory efficient. But the idea can be used with Binary search.  
Instead of finding all valid sequence we can manipulate one sequence to get length of LIS. 
This technique goes like this:
ex: 2 6 3 4 1 7 9
maintain an ans vector. Push first element of the sequence. 
ans-> [2]
start from index 1.
if current value is greater than ans.back() we push that value
ans-> [2 6]  
if current value is not greater than ans.back(), we find lower_bound of that value in ans vector and replace the value.
ans-> [2 3] 6 is replaced to 3
ans-> [2 3 4]
ans-> [1 3 4] 2 is replaced with 1
ans-> [1 3 4 7]
ans-> [1 3 4 7 9] maximum lenth is 5. 
This technique can only find length of LIS. 






21-Nov-23 : 3 hrs
22-Nov-23 : 2.5 hrs
23-Nov-23 : 5 hrs
24-Nov-23 : 4 hrs
25-Nov-23 : 6 hrs
26-Nov-23 : 4.5 hrs
-------------------------
avg : 4.1 hrs


27-Nov-23 : 6 hours
28-Nov-23 : 6 hours
29-Nov-23 : 6 hours
30-Nov-23 : 6 hours
1-Dec-23 : 2 hours
2-Dec-23 : 5 hours
----------------------
sum: 31 hrs
avg: 5.1 hrs 


03-Dec-23: 6 hours
04-Dec-23: 4 hours
05-Dec-23: 3 hours
06-Dec-23: 6 hours
07-Dec-23: 6.5 hours *********
08-Dec-23: 3 hours
-------------------------------
sum: 28.5 hours
avg: 4.75 hours


09-Dec-23: 0 hours // nani 
10-Dec-23: 0 hours // hometown
11-Dec-23: 4 hours
12-Dec-23: 2.5 hours
13-Dec-23: 7 hrs
14-Dec-23: 1 hrs
--------------------------
sum: 14.5 hrs
avg: 2.41 hrs

15-Dec-23: 2 hrs
16-Dec-23: 7 hrs
17-Dec-23: 3 hrs
18-Dec-23: 8 hrs
19-Dec-23: 
20-Dec-23: 
--------------------------

12-Jan-23: 7 hours
13-Jan-23: 5 hours 
14-Jan-23: 7 hours
15-Jan-23: 7 hours
16-Jan-23: 6 hours
17-jan-23: 


65067591-928f-4682-b5d4-74de91d36ca3













